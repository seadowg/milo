{"name":"milo","tagline":"A dirty FRP framework for async programming.","body":"## Description\r\n\r\nInspired by Functional Reactive Programming and async frameworks such as node.js 'milo' combines declarative stream-like\r\nevents with asynchronous multithreaded programming. There are two key concepts in milo: `EventStream` and `async`.\r\n\r\n### EventStream\r\n\r\nAn EventStream represents an infinite stream of values. We think of each value as occurring at a specific (but implicit) point in time.\r\nEventStreams can have callbacks registered to them that are executed on each occurrence. For instance:\r\n\r\n    val socket: EventStream[String] = new SocketEventStream(1337)\r\n    socket.bind {\r\n      message => println message\r\n    }\r\n\r\nEventStreams can also support standard stream operations. For instance we can `map` EventStreams:\r\n\r\n    val loweredSocket = socket.map(string => string.toLower())\r\n\r\nOr, `filter` them:\r\n\r\n    val shortSocket = socket.filter(string => string.length < 5)\r\n\r\nIn many ways EventStreams can be treated in a similar manner to Backbone.js' Event but with extra functionality.\r\n\r\n### 'async' Block\r\n\r\nMost of the basic work in milo can be carried out using callbacks on EventStreams but sometimes you won't want to hold up\r\nthe callback with long running operations such as I/O. To deal with this you can use the `async` block:\r\n\r\n    async {\r\n      database.query(\"SELECT * FROM users WHERE age == 25\")\r\n    }\r\n\r\nHere the this database operation would be executed asynchronously in a separate thread. Of course you will probably need access to the\r\nreturned value for some `async` blocks. To facilitate this an `aync` block returns an EventStream that occurs when the block has finished\r\nexecuting with the returned value:\r\n\r\n    async {\r\n      database.query(\"SELECT * FROM users WHERE age == 25\")\r\n    }.bind {\r\n      result =>\r\n        result.foreach {\r\n          row => println(row)\r\n        }\r\n    }\r\n\r\nThis allows EventStreams to be used in a similar manner to [Futures](http://docs.scala-lang.org/sips/pending/futures-promises.html)\r\nbut with more generalised semantics (Futures refer to a value that may not have been set yet where as an EventStream represents a\r\nstream of incoming values).\r\n\r\n## Using\r\n\r\nHere is a short example of a program written using milo and a SocketEventStream (which is not actually implemented in milo) that represents a unix socket\r\nwith an EventStream:\r\n\r\n    val socket = new SocketEventStream(1337)\r\n    socket.bind {\r\n      message =>\r\n        async {\r\n          println(message)\r\n        }\r\n    }\r\n\r\n    EventProcessor.start()\r\n\r\nThis program accepts `String` messages from a socket and prints them out (asynchronously). You'll notice that at the end of the program we do the following:\r\n\r\n    EventProcessor.start()\r\n\r\nThis call starts milo's event loop that processes occurring Events and runs callbacks. This should always be the last line in your milo code.\r\n\r\n### Installing\r\n\r\nYou can include milo as a dependency in sbt in the following way in your `build.sbt`:\r\n\r\n    libraryDependencies += \"milo\" % \"milo\" % \"0.1.0\" from \"http://raw.github.com/oetzi/milo/master/release/milo_2.10.0-0.1.0.jar\"\r\n\r\nYou can then need to require the following to enable full use of the framework:\r\n\r\n    import com.seadowg.milo.events._\r\n    import com.seadowg.milo.dsl._\r\n    import com.seadowg.runtime.EventProcessor\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}